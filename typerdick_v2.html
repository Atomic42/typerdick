<!DOCTYPE html>
<html>
  <head>
    <title>Typerdick</title>
    <meta charset="utf-8" />

    <!-- Disabling mobile zoom -->
    <meta content='user-scalable=0' name='viewport' />

    <script type="text/javascript">
(function() {
'use strict';

  var config = {
           minimumSpeed: 0.5     , // Cells per second
           acceleration: 0.05    , // Cells per second per second
        speedLossOnSlow: 0.2     , // Cells per second
              gridWidth: 30      , // Cells
             gridHeight: 20      , // Cells
     probabilityOfScore: 1 / 10  , // [0, 1]
      probabilityOfSlow: 1 / 120 , // [0, 1]
     probabilityOfBlock: 1 / 60  , // [0, 1]
  };

  Object.freeze(config);

  document.addEventListener('DOMContentLoaded', function() {
    var timer = Timer.new();
    var game = Game.new(config, timer);
    timer.run();
  });

  /*
   * Base: the base object, I never leave home without it
   */

  var Base = Object.create(Object);

  Base.new = function() {
    var clone = Object.create(this);
    clone.initialize.apply(clone, arguments);
    return clone;
  };

  Base.initialize = function() {
  };

  /*
   * Timer: keeps the bullshit synchronized
   */

  var Timer = Object.create(Base);

  Timer.initialize = function() {
    this._tickActions = [];
    this._isPaused = true;
    this.reset();
  };

  Timer._getTotalElapsedTime = function() {
    return this._isPaused ? this._savedElapsedTime : Date.now() - this._previousTime;
  };

  Timer._tick = function() {
    var timer = this;
    function tick() {
      if (timer._isPaused) {
         return;
      }
      requestAnimationFrame(tick);

      var totalElapsedTime = timer._getTotalElapsedTime();
      timer._relativeElapsedTime = totalElapsedTime - timer._lastTickElapsedTime;

      timer._tickActions.forEach(function(tickAction) {
         tickAction(timer._relativeElapsedTime, totalElapsedTime);
      });

      timer._lastTickElapsedTime = totalElapsedTime;
    }
    tick();
  };

  Timer.run = function() {
    this._previousTime = Date.now() - this._savedElapsedTime;
    this._isPaused = false;
    this._tick();
  };

  Timer.pause = function() {
    this._savedElapsedTime = this.getTotalElapsedTime();
    this._isPaused = true;
  };

  Timer.reset = function() {
    this._previousTime = Date.now();
    this._lastTickElapsedTime = 0;
    this._savedElapsedTime = 0;
    this._isPaused = true;
  };

  Timer.isPaused = function() {
    return this._isPaused;
  };

  Timer.addTickAction = function(tickAction) {
    this._tickActions.push(tickAction);
  };

  /*
   * Cell: the smallest unit of bullshit
   */

  var Cell = Object.create(Base);

  Cell.initialize = function(x, y) {
    this.x = x;
    this.y = y;
  };

  /*
   * LetterCell: typographical bullshit
   */

  var LetterCell = Object.create(Cell);

  LetterCell.new = function(x, y) {
    Cell.initialize.call(this, x, y);
    this.type = 0;
    this.label = '';
  };

  LetterCell.modifiers = {
    score: 1 ,
     slow: 2 ,
    block: 4 ,
  };

  /*
   * PlayerCell: bullshit with a brain
   */

  var PlayerCell = Object.create(Cell);

  PlayerCell.initialize = function(x, y) {
    Cell.initialize.call(this, x, y);
  };

  /*
   * Grid: the bullshit organizer
   */

  var Grid = Object.create(Base);

  Grid.initialize = function(width, height) {
    this.width = width; // Number of cells
    this.height = height; // Number of cells
    this._cells = [];
    for (var x = 0; x < width; ++x) {
      var column = [];
      for (var y = 0; y < height; ++y) {
        column.push(Cell.new(x, y));
      }
      this._cells.push(column);
    }
    this.cellCycleCallback = function() {};
  };

  Grid.getCell = function(x, y) {
    return this._cells[x][y];
  };

  Grid.cycle = function() {
    var column = this._cells[0];
    for (var y = 0; y < column.length; ++y) {
      var cell = column[y];

      var clashingCells = ([
        // Two columns back
        this._cells[this._cells.length - 1][y - 2] ,
        this._cells[this._cells.length - 1][y - 1] ,
        this._cells[this._cells.length - 1][y - 0] ,
        this._cells[this._cells.length - 1][y - 1] ,
        this._cells[this._cells.length - 1][y - 2] ,

        // One column back
        this._cells[this._cells.length - 2][y - 2] ,
        this._cells[this._cells.length - 2][y - 1] ,
        this._cells[this._cells.length - 2][y - 0] ,
        this._cells[this._cells.length - 2][y - 1] ,
        this._cells[this._cells.length - 2][y - 2] ,

        // Current column
        column[y - 2]                              ,
        column[y - 1]                              ,
      ]);

      var clashingCellLabels = clashingCells.map(function(cell) {
        if (cell === undefined) {
          return '';
        }
        return cell.label;
      }).join('');
      
      var possibleCellLabels = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ').replace(new RegExp('[' + clashingCellLabels + ']', 'g'), '');
      var currentCellLabel = possibleCellLabels[parseInt(Math.random() * possibleCellLabels.length)];
      cell.label = currentCellLabel;
      cell.type = 0;

      this.cellCycleCallback(cell);
    }
    this._cells.push(this._cells.shift());
  };

  Grid.toString = function() {
    var rows = [];
    this._cells.forEach(function(column) {
      column.forEach(function(cell, y) {
        rows[y] = (rows[y] || '') + (cell.label || '-');
      });
    });
    return rows.join('\n');
  };

  /*
   * Game: that which gives the bullshit meaning
   */

  var Game = Object.create(Base);

  Game.initialize = function(options, timer) {
    this._minimumSpeed = options.minimumSpeed; 
    this._acceleration = options.acceleration; 
    this._speedLossOnSlow = options._speedLossOnSlow; 
    this._probabilityOfPoints = options._probabilityOfPoints; 
    this._probabilityOfSlow = options._probabilityOfSlow; 
    this._probabilityOfBlock = options._probabilityOfBlock; 

    this._speed = this._minimumSpeed;
    this._offset = 0;

    this._grid = Grid.new(options.gridWidth, options.gridHeight);

    this._timer = timer;

    this._displayNode = document.querySelector('.game_for_now');

    var game = this; // Close this game object under the callbacks below

    this._grid.cellCycleCallback = function(cell) {
      if (Math.random() > game.probabilityOfSlow) {
        cell.type &= LetterCell.modifiers.slow;
      }
      else if (Math.random() > game._probabilityOfBlock) {
        cell.type &= LetterCell.modifiers.block;
      }
      else if (Math.random() > game._probabilityOfPoints) {
        cell.type &= LetterCell.modifiers.score;
      }
    };

    this._timer.addTickAction(function(relativeElapsedTime, totalElapsedTime) {
      var relativeElapsedTimeInSeconds = relativeElapsedTime / 1000;

      game._offset += 1 * game._speed * relativeElapsedTimeInSeconds;
      game._speed += game._acceleration * relativeElapsedTimeInSeconds;

      while (game._offset >= 1) {
        game._grid.cycle();
        game._offset -= 1;
        game._displayNode.textContent = game._grid.toString();
      }
    });
  };

})();
    </script>
    <style type="text/css">
*,
*::before,
*::after {
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
       -o-user-select: none;
       -k-user-select: none;
          user-select: none;
}

html,
body {
  padding: 0;
  margin: 0;
  height: 100%;
}

body {
  font-family: sans-serif;
  font-size: 0;
  white-space: nowrap;
  text-align: center;
}

body::before {
  content: '';
  height: 100%;
  display: inline-block;
  vertical-align: middle;
}

.main {
  font-size: 14px;
  display: inline-block;
  vertical-align: middle;
  white-space: normal;
}

.game_for_now {
  font-size: 12px;
  border: 1px solid black;
  width: 300px;
  height: 300px;
}
    </style>
  </head>
  <body>
    <div class="main">
      <pre class="game_for_now"></pre>
    </div>
  </body>
</html>
